{% extends "base.html" %} {% block content %}
<div class="h-svh flex flex-col">
  <div id="player" class="w-full flex-1"></div>
  <div class="h-fit">
    <div id="data-display" class="p-2 bg-gray-100 w-full">
      <pre id="data-content" class=" h-16 overflow-hidden break-all"></pre>
    </div>
    <div class="flex items-center gap-2 p-1">
      <span>Language</span>
      <select
        id="language-select"
        class="inline-block border-2 border-dark rounded-md p-1"
      ></select>
      <span class="border-l pl-2 ml-2">Start Time:</span>
      <span id="start-time">--:--:--</span>
      <span class="border-l pl-2 ml-2">Offset(Secs):</span>
      <input type="number" id="offset-seconds" class="rounded-md p-1 border-2 border-dark w-16" value="0" step="0.1" />
      <div id="connection-status" class="text-sm ms-auto">
        <span
          id="status-indicator"
          class="inline-block w-3 h-3 rounded-full bg-gray-400"
        ></span>
        <span id="status-text">Connecting...</span>
      </div>
    </div>
    <div></div>
  </div>
</div>
{% endblock %} {% block scripts %}
<script src="https://www.youtube.com/iframe_api"></script>
<script>
  var player;
  let currentLanguage = '';
  let transcriptionsData = {{ data | tojson(indent = 2) }};
  let timeoutId = null;
  let lastTranscription = null;

  function getLanguages() {
    if (transcriptionsData.transcriptions) {
      const languages = Object.keys(transcriptionsData.transcriptions[0].result.translated);
      const languageSelect = document.getElementById('language-select');
      languages.forEach(language => {
        if (languageSelect.querySelector(`option[value="${language}"]`)) {
          return;
        }
        const option = document.createElement('option');
        option.value = language;
        option.textContent = language;
        languageSelect.appendChild(option);
      });
    }
  }

  function onYouTubeIframeAPIReady() {
    player = new YT.Player('player', {
      height: '100%',
      width: '100%',
      videoId: '{{ id }}',
      events: {
          'onReady': onPlayerReady,
      }
    });
  }

  function onPlayerReady(event) {
    event.target.playVideo();
  }

  function getCurrentTime() {
    const dataContent = document.getElementById('data-content');
    dataContent.scrollTop = dataContent.scrollHeight;
    if (player && typeof player.getCurrentTime === 'function') {
      const currentTime = player.getCurrentTime() + transcriptionsData.stream_start_time;
      const videoStartDatetime = new Date(transcriptionsData.stream_start_time * 1000);
      const startTime = document.getElementById('start-time');
      startTime.textContent = videoStartDatetime.toLocaleString('zh-TW', { timeZoneName: 'short' });
      console.log("currentTime", currentTime, "init time", transcriptionsData.stream_start_time);
      getLanguages();
      // Update the display
      if (transcriptionsData?.transcriptions) {
        const offsetSeconds = parseInt(document.getElementById('offset-seconds').value);
        for (const transcription of transcriptionsData.transcriptions) {
          const start_time = transcription.start_time + offsetSeconds;
          const end_time = transcription.end_time + offsetSeconds;
          if (start_time < currentTime && end_time > currentTime) {
            if (lastTranscription && lastTranscription === transcription.id) {
              continue;
            }
            lastTranscription = transcription.id;
            const currentLanguage = document.getElementById('language-select').value;
            dataContent.textContent += '\n' + transcription.result.translated[currentLanguage];
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            timeoutId = setTimeout(() => {
                dataContent.textContent += ' ';
                timeoutId = null;
            }, 3000);
            break;
          }
        }
      }
    }
  }

  document.addEventListener('DOMContentLoaded', function() {
      setInterval(getCurrentTime, 100);
      const statusIndicator = document.getElementById('status-indicator');
      const statusText = document.getElementById('status-text');

      // Connect to SSE endpoint
      const eventSource = new EventSource('/api/sse/{{ id }}');

      eventSource.onopen = function() {
          statusIndicator.className = 'inline-block w-3 h-3 rounded-full bg-green-500';
          statusText.textContent = 'Connected';
          console.log('SSE connection opened');
      };

      eventSource.onerror = function(event) {
          statusIndicator.className = 'inline-block w-3 h-3 rounded-full bg-red-500';
          statusText.textContent = 'Connection error';
          console.error('SSE connection error:', event);
      };

      eventSource.onmessage = function(event) {
          try {
              const data = JSON.parse(event.data);
              console.log('SSE message received:', data);

              // Skip keepalive messages
              if (data.type === 'keepalive') {
                  return;
              }

              // Handle connection message
              if (data.type === 'connected') {
                  statusText.textContent = 'Connected to session: ' + data.id;
                  return;
              }
              if (data.type === 'update') {
                  transcriptionsData = data.data;
              }
          } catch (error) {
              console.error('Error parsing SSE data:', error);
          }
      };

      // Cleanup on page unload
      window.addEventListener('beforeunload', function() {
          eventSource.close();
      });
  });
</script>
{% endblock %}
