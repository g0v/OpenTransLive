{% extends "base.html" %} {% block content %}
<div class="h-svh flex flex-col">
  <div id="player" class="w-full flex-1"></div>
  <div class="h-fit">
    <div id="data-display" class="p-2 bg-gray-100 w-full">
      <pre id="data-content" class=" h-16 overflow-hidden break-all"></pre>
    </div>
    <div class="flex items-center gap-2 p-1">
      <span>Language</span>
      <select
        id="language-select"
        class="inline-block border-2 border-dark rounded-md p-1"
      ></select>
      <span class="border-l pl-2 ml-2">Start Time:</span>
      <span id="start-time">--:--:--</span>
      <span class="border-l pl-2 ml-2">Offset(Secs):</span>
      <input type="number" id="offset-seconds" class="rounded-md p-1 border-2 border-dark w-16" value="5" step="0.1" />
      <div id="connection-status" class="text-sm ms-auto">
        <span
          id="status-indicator"
          class="inline-block w-3 h-3 rounded-full bg-gray-400"
        ></span>
        <span id="status-text">Connecting...</span>
      </div>
    </div>
    <div></div>
  </div>
</div>
{% endblock %} {% block scripts %}
<script src="https://www.youtube.com/iframe_api"></script>
<script>
  var player;
  let currentLanguage = '';
  let transcriptionsData = {{ data | tojson(indent = 2) }};
  let timeoutId = null;
  let lastTranscription = null;

  function getLanguages() {
    if (transcriptionsData.transcriptions && 
        transcriptionsData.transcriptions.length > 0 && 
        transcriptionsData.transcriptions[0].result && 
        transcriptionsData.transcriptions[0].result.translated) {
      const languages = Object.keys(transcriptionsData.transcriptions[0].result.translated);
      const languageSelect = document.getElementById('language-select');
      languages.forEach(language => {
        if (languageSelect.querySelector(`option[value="${language}"]`)) {
          return;
        }
        const option = document.createElement('option');
        option.value = language;
        option.textContent = language;
        languageSelect.appendChild(option);
      });
    }
  }

  function onYouTubeIframeAPIReady() {
    player = new YT.Player('player', {
      height: '100%',
      width: '100%',
      videoId: '{{ id }}',
      events: {
          'onReady': onPlayerReady,
      }
    });
  }

  function onPlayerReady(event) {
    event.target.playVideo();
  }

  function getCurrentTime() {
    const dataContent = document.getElementById('data-content');
    dataContent.scrollTop = dataContent.scrollHeight;
    if (player && typeof player.getCurrentTime === 'function') {
      const currentTime = player.getCurrentTime() + transcriptionsData.stream_start_time;
      const videoStartDatetime = new Date(transcriptionsData.stream_start_time * 1000);
      const startTime = document.getElementById('start-time');
      startTime.textContent = videoStartDatetime.toLocaleString('zh-TW', { timeZoneName: 'short' });
      console.log("currentTime", currentTime, "init time", transcriptionsData.stream_start_time);
      getLanguages();
      // Update the display
      if (transcriptionsData?.transcriptions) {
        const offsetSeconds = parseInt(document.getElementById('offset-seconds').value);
        for (const transcription of transcriptionsData.transcriptions) {
          const start_time = transcription.start_time + offsetSeconds;
          const end_time = transcription.end_time + offsetSeconds;
          if (start_time < currentTime && end_time > currentTime) {
            if (lastTranscription && lastTranscription === start_time) {
              break;
            }
            lastTranscription = start_time;
            const currentLanguage = document.getElementById('language-select').value;
            dataContent.textContent += '\n' + transcription.result.translated[currentLanguage];
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            timeoutId = setTimeout(() => {
                dataContent.textContent += ' ';
                timeoutId = null;
            }, 3000);
            break;
          }
        }
      }
    }
  }

  document.addEventListener('DOMContentLoaded', function() {
      setInterval(getCurrentTime, 300);
      const statusIndicator = document.getElementById('status-indicator');
      const statusText = document.getElementById('status-text');

      // Connect to WebSocket
      const socket = io();

      socket.on('connect', function() {
          statusIndicator.className = 'inline-block w-3 h-3 rounded-full bg-green-500';
          statusText.textContent = 'Connected';
          console.log('WebSocket connection opened');
          
          // Join the session room
          socket.emit('join_session', { session_id: '{{ id }}' });
      });

      socket.on('disconnect', function() {
          statusIndicator.className = 'inline-block w-3 h-3 rounded-full bg-red-500';
          statusText.textContent = 'Disconnected';
          console.log('WebSocket connection closed');
      });

      socket.on('connected', function(data) {
          console.log('WebSocket connected:', data);
      });

      socket.on('joined_session', function(data) {
          console.log('Joined session:', data);
          statusText.textContent = 'Connected to session: ' + data.session_id;
      });

      socket.on('transcription_update', function(data) {
          console.log('Transcription update received:', data);
          transcriptionsData["transcriptions"].push(data);
          transcriptionsData["transcriptions"].sort((a, b) => a.start_time - b.start_time);
      });

      socket.on('error', function(data) {
          console.error('WebSocket error:', data);
          statusIndicator.className = 'inline-block w-3 h-3 rounded-full bg-red-500';
          statusText.textContent = 'Error: ' + data.message;
      });

      // Cleanup on page unload
      window.addEventListener('beforeunload', function() {
          socket.disconnect();
      });
  });
</script>
{% endblock %}
